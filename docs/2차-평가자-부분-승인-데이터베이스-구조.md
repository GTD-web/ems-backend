# 2차 평가자별 부분 승인 데이터베이스 구조

## 현재 문제점

### 기존 구조의 한계

1. **`employee_evaluation_step_approval` 테이블 구조**
   - 평가기간-직원 맵핑당 **1개만** 존재 (`evaluationPeriodEmployeeMappingId` UNIQUE)
   - `secondaryEvaluationStatus` 필드가 **단일 필드**로 모든 2차 평가자에게 공통 적용
   - 평가자별 개별 승인 상태를 저장할 수 없음

2. **현재 동작 방식**
   - `revision_requested`: 재작성 요청 테이블(`evaluation_revision_request`)에 평가자별로 저장 → **정상 동작**
   - `approved`: `stepApproval.secondaryEvaluationStatus` 단일 필드에만 저장 → **평가자별 구분 불가**

## 해결 방안

### 방안 1: 평가자별 승인 상태 별도 테이블 생성 (권장)

#### 새로운 테이블: `secondary_evaluation_step_approval`

```sql
CREATE TABLE secondary_evaluation_step_approval (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- 관계 필드
    evaluation_period_employee_mapping_id UUID NOT NULL,
    evaluator_id UUID NOT NULL,
    
    -- 승인 상태
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    -- 'pending' | 'approved' | 'revision_requested' | 'revision_completed'
    
    -- 승인 정보
    approved_by UUID NULL,
    approved_at TIMESTAMP WITH TIME ZONE NULL,
    
    -- 재작성 요청 정보 (재작성 요청 테이블과 연결)
    revision_request_id UUID NULL,
    
    -- 감사 정보
    created_by UUID NOT NULL,
    updated_by UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE NULL,
    
    -- 제약조건
    CONSTRAINT fk_secondary_approval_mapping 
        FOREIGN KEY (evaluation_period_employee_mapping_id) 
        REFERENCES evaluation_period_employee_mapping(id),
    CONSTRAINT fk_secondary_approval_evaluator 
        FOREIGN KEY (evaluator_id) 
        REFERENCES employee(id),
    CONSTRAINT fk_secondary_approval_revision_request 
        FOREIGN KEY (revision_request_id) 
        REFERENCES evaluation_revision_request(id),
    
    -- 유니크 제약조건: 평가기간-직원-평가자 조합당 1개만 존재
    CONSTRAINT uk_secondary_approval_mapping_evaluator 
        UNIQUE (evaluation_period_employee_mapping_id, evaluator_id, deleted_at)
);

-- 인덱스
CREATE INDEX idx_secondary_approval_mapping 
    ON secondary_evaluation_step_approval(evaluation_period_employee_mapping_id);
CREATE INDEX idx_secondary_approval_evaluator 
    ON secondary_evaluation_step_approval(evaluator_id);
CREATE INDEX idx_secondary_approval_status 
    ON secondary_evaluation_step_approval(status);
```

#### 기존 테이블 수정

**`employee_evaluation_step_approval` 테이블**
- `secondaryEvaluationStatus` 필드는 **하위 호환성**을 위해 유지
- 전체 통합 상태 계산용으로 사용 (모든 평가자가 approved인지 확인)
- 평가자별 상태는 새 테이블에서 관리

### 방안 2: 재작성 요청 테이블 확장 (대안)

기존 `evaluation_revision_request` 테이블을 확장하여 `approved` 상태도 저장

#### 장점
- 별도 테이블 생성 불필요
- 기존 재작성 요청 로직 재사용 가능

#### 단점
- 재작성 요청과 승인 상태의 개념적 혼재
- 테이블 이름과 목적이 불일치

## 권장 구조 (방안 1)

### 테이블 관계

```
evaluation_period_employee_mapping (1)
    ↓
employee_evaluation_step_approval (1)  -- 전체 통합 상태
    ↓
secondary_evaluation_step_approval (N)  -- 평가자별 개별 상태
    ↓
evaluation_revision_request (N)  -- 재작성 요청 (기존)
```

### 데이터 저장 예시

**시나리오**: 평가기간 A, 직원 B에 대해 2차 평가자 C, D, E가 있는 경우

```
employee_evaluation_step_approval (1개)
├─ id: step-approval-1
├─ evaluationPeriodEmployeeMappingId: mapping-1
└─ secondaryEvaluationStatus: 'pending' (통합 상태)

secondary_evaluation_step_approval (3개)
├─ id: sec-approval-1
│  ├─ evaluationPeriodEmployeeMappingId: mapping-1
│  ├─ evaluatorId: evaluator-C
│  └─ status: 'approved'
│
├─ id: sec-approval-2
│  ├─ evaluationPeriodEmployeeMappingId: mapping-1
│  ├─ evaluatorId: evaluator-D
│  └─ status: 'pending'
│
└─ id: sec-approval-3
   ├─ evaluationPeriodEmployeeMappingId: mapping-1
   ├─ evaluatorId: evaluator-E
   └─ status: 'revision_requested'
```

### 통합 상태 계산 로직

```typescript
// 모든 평가자의 상태를 확인하여 통합 상태 결정
function calculateSecondaryEvaluationStatus(
  approvals: SecondaryEvaluationStepApproval[]
): StepApprovalStatus {
  if (approvals.length === 0) {
    return 'pending';
  }
  
  // 모든 평가자가 approved인 경우
  if (approvals.every(a => a.status === 'approved')) {
    return 'approved';
  }
  
  // 하나라도 revision_requested인 경우
  if (approvals.some(a => a.status === 'revision_requested')) {
    return 'revision_requested';
  }
  
  // 하나라도 revision_completed인 경우
  if (approvals.some(a => a.status === 'revision_completed')) {
    return 'revision_completed';
  }
  
  return 'pending';
}
```

## 마이그레이션 전략

### DDL 파일 위치
- **마이그레이션 스크립트**: `scripts/ddl/create-secondary-evaluation-step-approval-table.sql`
- 상세한 DDL 및 마이그레이션 로직은 해당 파일 참조

### 1단계: 새 테이블 생성
- `secondary_evaluation_step_approval` 테이블 생성
- 외래키 제약조건 추가
- 유니크 인덱스 생성 (평가기간-직원-평가자 조합당 1개)
- 성능 최적화를 위한 인덱스 생성
- 기존 데이터는 그대로 유지

### 2단계: 데이터 마이그레이션
- 기존 `stepApproval.secondaryEvaluationStatus`가 `approved`인 경우
- `evaluation_line_mappings` 테이블에서 해당 평가기간-직원의 모든 2차 평가자 조회
- 각 2차 평가자에 대해 `approved` 상태로 레코드 생성
- 승인자 정보(`approvedBy`, `approvedAt`) 복사

### 3단계: 코드 수정
- 평가자별 승인 로직을 새 테이블 사용하도록 변경
- 기존 `secondaryEvaluationStatus` 필드는 통합 상태 계산용으로만 사용
- 쿼리 로직 변경 (참고: `docs/2차-평가자-부분-승인-쿼리-로직-변경.md`)

### 4단계: 검증
- 기존 기능 정상 동작 확인
- 부분 승인 기능 테스트
- 마이그레이션된 데이터 검증

## 주요 변경 사항 요약

| 항목 | 변경 전 | 변경 후 |
|------|---------|---------|
| **평가자별 상태 저장** | 단일 필드 (공통) | 별도 테이블 (개별) |
| **부분 승인 지원** | ❌ 불가능 | ✅ 가능 |
| **재작성 요청** | ✅ 정상 동작 | ✅ 정상 동작 (유지) |
| **통합 상태** | 단일 필드 | 계산된 값 (하위 호환) |

## 참고사항

- 기존 `employee_evaluation_step_approval.secondaryEvaluationStatus` 필드는 **하위 호환성**을 위해 유지
- 통합 상태 계산 시 참고용으로 사용
- 실제 평가자별 상태는 `secondary_evaluation_step_approval` 테이블에서 관리

