# 2차 평가자 부분 승인 쿼리 로직 변경 가이드

## 개요

`secondary_evaluation_step_approval` 테이블로 분리된 구조에 맞게 대시보드 조회 쿼리 로직을 변경하는 방법을 정리합니다.

## 현재 문제점

### 기존 로직의 한계

```typescript
// 현재: step-approval.utils.ts
// 재작성 요청이 없으면 stepApproval.secondaryEvaluationStatus 확인
// → 모든 평가자에게 동일한 상태 적용 (부분 승인 불가)
const stepApprovalStatus = stepApproval?.secondaryEvaluationStatus;
if (stepApprovalStatus === 'approved') {
  finalStatus = 'approved';  // 모든 평가자가 approved로 보임
}
```

**문제**: 
- `stepApproval.secondaryEvaluationStatus`는 단일 필드
- 모든 2차 평가자가 동일한 상태를 공유
- 평가자별 개별 승인 상태를 구분할 수 없음

## 변경 방안

### 1. 새로운 테이블 조회 함수 추가

#### `step-approval.utils.ts` 수정

```typescript
import { Repository, IsNull } from 'typeorm';
import { SecondaryEvaluationStepApproval } from '@domain/sub/secondary-evaluation-step-approval/secondary-evaluation-step-approval.entity';

/**
 * 평가자별 2차 평가 단계 승인 상태를 조회한다 (개선 버전)
 * 
 * 1. 재작성 요청 테이블에서 평가자별 재작성 요청 상태 조회
 * 2. 재작성 요청이 없으면 secondary_evaluation_step_approval 테이블에서 approved 상태 조회
 * 3. 둘 다 없으면 pending 상태 반환
 */
export async function 평가자별_2차평가_단계승인_상태를_조회한다(
  evaluationPeriodId: string,
  employeeId: string,
  evaluatorId: string,
  mappingId: string,  // evaluation_period_employee_mapping.id
  revisionRequestRepository: Repository<EvaluationRevisionRequest>,
  revisionRequestRecipientRepository: Repository<EvaluationRevisionRequestRecipient>,
  secondaryStepApprovalRepository: Repository<SecondaryEvaluationStepApproval>,  // 새로 추가
): Promise<EvaluatorRevisionRequestStatus & {
  approvedBy: string | null;
  approvedAt: Date | null;
}> {
  // 1. 재작성 요청 조회 (기존 로직 유지)
  const recipient = await revisionRequestRecipientRepository
    .createQueryBuilder('recipient')
    .leftJoinAndSelect('recipient.revisionRequest', 'request')
    .where('request.evaluationPeriodId = :evaluationPeriodId', {
      evaluationPeriodId,
    })
    .andWhere('request.employeeId = :employeeId', { employeeId })
    .andWhere('request.step = :step', { step: 'secondary' })
    .andWhere('recipient.recipientId = :evaluatorId', { evaluatorId })
    .andWhere('recipient.recipientType = :recipientType', {
      recipientType: RecipientType.SECONDARY_EVALUATOR,
    })
    .andWhere('recipient.deletedAt IS NULL')
    .andWhere('request.deletedAt IS NULL')
    .orderBy('request.requestedAt', 'DESC')
    .getOne();

  // 2. 재작성 요청이 있는 경우
  if (recipient && recipient.revisionRequest) {
    const request = recipient.revisionRequest;
    const status: StepApprovalStatus = recipient.isCompleted
      ? 'revision_completed'
      : 'revision_requested';

    return {
      evaluatorId,
      status,
      revisionRequestId: request.id,
      revisionComment: request.comment,
      isCompleted: recipient.isCompleted,
      completedAt: recipient.completedAt,
      responseComment: recipient.responseComment,
      requestedAt: request.requestedAt,
      approvedBy: null,  // 재작성 요청 중에는 승인 정보 없음
      approvedAt: null,
    };
  }

  // 3. 재작성 요청이 없는 경우: 새 테이블에서 approved 상태 조회
  const secondaryApproval = await secondaryStepApprovalRepository.findOne({
    where: {
      evaluationPeriodEmployeeMappingId: mappingId,
      evaluatorId: evaluatorId,
      deletedAt: IsNull(),
    },
  });

  if (secondaryApproval && secondaryApproval.status === 'approved') {
    return {
      evaluatorId,
      status: 'approved' as StepApprovalStatus,
      revisionRequestId: null,
      revisionComment: null,
      isCompleted: false,
      completedAt: null,
      responseComment: null,
      requestedAt: null,
      approvedBy: secondaryApproval.approvedBy,
      approvedAt: secondaryApproval.approvedAt,
    };
  }

  // 4. 둘 다 없으면 pending 상태
  return {
    evaluatorId,
    status: 'pending' as StepApprovalStatus,
    revisionRequestId: null,
    revisionComment: null,
    isCompleted: false,
    completedAt: null,
    responseComment: null,
    requestedAt: null,
    approvedBy: null,
    approvedAt: null,
  };
}

/**
 * 여러 평가자별 2차 평가 단계 승인 상태를 조회한다 (개선 버전)
 */
export async function 평가자들별_2차평가_단계승인_상태를_조회한다(
  evaluationPeriodId: string,
  employeeId: string,
  evaluatorIds: string[],
  mappingId: string,  // 새로 추가
  revisionRequestRepository: Repository<EvaluationRevisionRequest>,
  revisionRequestRecipientRepository: Repository<EvaluationRevisionRequestRecipient>,
  secondaryStepApprovalRepository: Repository<SecondaryEvaluationStepApproval>,  // 새로 추가
): Promise<Array<EvaluatorRevisionRequestStatus & {
  approvedBy: string | null;
  approvedAt: Date | null;
}>> {
  if (evaluatorIds.length === 0) {
    return [];
  }

  // 병렬로 각 평가자별 상태 조회
  const statuses = await Promise.all(
    evaluatorIds.map((evaluatorId) =>
      평가자별_2차평가_단계승인_상태를_조회한다(
        evaluationPeriodId,
        employeeId,
        evaluatorId,
        mappingId,  // 새로 추가
        revisionRequestRepository,
        revisionRequestRecipientRepository,
        secondaryStepApprovalRepository,  // 새로 추가
      ),
    ),
  );

  return statuses;
}
```

### 2. Handler 수정

#### `get-employee-evaluation-period-status.handler.ts` 수정

```typescript
// 기존 코드 (변경 전)
const secondaryEvaluationStatuses =
  await 평가자들별_2차평가_단계승인_상태를_조회한다(
    evaluationPeriodId,
    employeeId,
    secondaryEvaluatorIds,
    this.revisionRequestRepository,
    this.revisionRequestRecipientRepository,
  );

// 변경 후
const secondaryEvaluationStatuses =
  await 평가자들별_2차평가_단계승인_상태를_조회한다(
    evaluationPeriodId,
    employeeId,
    secondaryEvaluatorIds,
    result.mapping_id,  // mappingId 추가
    this.revisionRequestRepository,
    this.revisionRequestRecipientRepository,
    this.secondaryStepApprovalRepository,  // 새 Repository 추가
  );
```

#### 상태 결정 로직 수정

```typescript
// 기존 코드 (변경 전)
} else {
  // 재작성 요청이 없는 경우, stepApproval 상태 확인
  const stepApprovalStatus =
    stepApproval?.secondaryEvaluationStatus;
  if (stepApprovalStatus === 'approved') {
    finalStatus = 'approved';
    approvedBy =
      stepApproval?.secondaryEvaluationApprovedBy ?? null;
    approvedAt =
      stepApproval?.secondaryEvaluationApprovedAt ?? null;
  } else if (stepApprovalStatus === 'revision_completed') {
    finalStatus = 'revision_completed';
  } else {
    finalStatus = 'pending';
  }
}

// 변경 후
} else {
  // 재작성 요청이 없는 경우, statusInfo에서 이미 새 테이블 조회 결과 포함
  // statusInfo는 평가자별_2차평가_단계승인_상태를_조회한다에서 반환된 값
  finalStatus = statusInfo?.status ?? 'pending';
  approvedBy = statusInfo?.approvedBy ?? null;
  approvedAt = statusInfo?.approvedAt ?? null;
}
```

### 3. 통합 상태 계산 로직 (변경 없음)

```typescript
// secondary.status는 모든 평가자 상태를 기반으로 계산
// 이 로직은 변경 없음 (이미 개별 상태를 기반으로 계산하고 있음)

const finalSecondaryStatus:
  | 'pending'
  | 'approved'
  | 'revision_requested'
  | 'revision_completed' = allSecondaryApproved
  ? 'approved'
  : allSecondaryCompleted
    ? 'revision_completed'
    : secondaryEvaluationStatusesWithEvaluatorInfo.some(
          (s) => s.status === 'revision_requested',
        )
      ? 'revision_requested'
      : 'pending';
```

## 데이터 흐름

### 변경 전

```
1. 재작성 요청 테이블 조회 (평가자별)
   ↓ 없으면
2. stepApproval.secondaryEvaluationStatus 확인 (단일 필드, 모든 평가자 공통)
   ↓
3. 모든 평가자에게 동일한 상태 적용
```

### 변경 후

```
1. 재작성 요청 테이블 조회 (평가자별)
   ↓ 없으면
2. secondary_evaluation_step_approval 테이블 조회 (평가자별)
   ↓
3. 각 평가자별로 독립적인 상태 반환
   ↓
4. 모든 평가자 상태를 기반으로 통합 상태 계산 (secondary.status)
```

## 응답 구조

### 개별 평가자 상태 (`evaluators[].status`)

```json
{
  "secondary": {
    "evaluators": [
      {
        "evaluator": {
          "id": "evaluator-id-1",
          "name": "김종식"
        },
        "status": "approved",  // 개별 상태 (새 테이블에서 조회)
        "assignedWbsCount": 2,
        "completedEvaluationCount": 2,
        "isSubmitted": true
      },
      {
        "evaluator": {
          "id": "evaluator-id-2",
          "name": "이영희"
        },
        "status": "pending",  // 개별 상태 (새 테이블에서 조회)
        "assignedWbsCount": 1,
        "completedEvaluationCount": 0,
        "isSubmitted": false
      }
    ],
    "status": "pending",  // 통합 상태 (모든 평가자 상태 기반 계산)
    "isSubmitted": false,
    "totalScore": null,
    "grade": null
  }
}
```

## 주요 변경 사항 요약

| 항목 | 변경 전 | 변경 후 |
|------|---------|---------|
| **재작성 요청 없을 때** | `stepApproval.secondaryEvaluationStatus` (단일 필드) | `secondary_evaluation_step_approval` 테이블 (평가자별) |
| **평가자별 상태** | ❌ 구분 불가 | ✅ 개별 조회 가능 |
| **부분 승인** | ❌ 불가능 | ✅ 가능 |
| **통합 상태 계산** | 단일 필드 값 | 모든 평가자 상태 기반 계산 (변경 없음) |

## 마이그레이션 체크리스트

- [ ] `SecondaryEvaluationStepApproval` 엔티티 생성
- [ ] `secondary_evaluation_step_approval` 테이블 생성
- [ ] `step-approval.utils.ts` 함수 수정
- [ ] `get-employee-evaluation-period-status.handler.ts` 수정
- [ ] Repository 주입 추가
- [ ] 기존 데이터 마이그레이션 (기존 `approved` 상태를 새 테이블로 이동)
- [ ] 테스트: 부분 승인 시나리오 검증

## 참고사항

- `stepApproval.secondaryEvaluationStatus` 필드는 **하위 호환성**을 위해 유지
- 통합 상태 계산 시 참고용으로 사용 (실제 개별 상태는 새 테이블에서 관리)
- 재작성 요청 로직은 기존과 동일하게 유지

